<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>spr_player_fall</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>-10</depth>
  <persistent>0</persistent>
  <parentName>&lt;undefined&gt;</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Initialize

// Movement Variables
dash_max=1
jump_max=2
dash_count=dash_max
jump_count=jump_max

move_hsp=0
dash_hsp=0
fall_hsp=0
wall_hsp=0
jump_hsp=0
hsp=0
vsp=0
grav=0.6

dash_dir=0

// Other
can_throw=true
state=s.idle
move_speed=6
jump_speed=10
dash_timer=0
move_timer=0
wall_timer=0

ring_reset=true
flash=0
flash_lock=false


</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="1" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// obj_host.death_count

global.death_count+=1

stop_snd(snd_player_move_wall)

</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Pause Check

if obj_host.paused
{
    image_speed=0
    exit
}
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Non-Wall Collisions

sp=instance_place(x,y,obj_savepoint)
if sp!=noone and sp.state=s.close
{
    obj_savepoint.state=s.close
    sp.state=s.open
    sp.peek=120
    create_particles(sp.x+10,sp.y+10,'savepoint_get')
}

if obj_debug.player_invincible!=true
{
    if place_meeting(x,y,obj_spike_shard)
    {
        instance_destroy()
        instance_create(x,y,obj_player_death)
    }
    
    db=instance_place(x,y,obj_dirtball)
    if db!=noone
    {
        instance_destroy()
        instance_create(x,y,obj_player_death)
        with(db)
        {
            instance_destroy()
            //create_particles('dirtball_hit')
        }
    }
}

tp=instance_place(x,y,obj_telepoint)
if tp!=noone
{
    jump_count=jump_max
    dash_count=dash_max
    
    create_particles(tp.x+10,tp.y+10,'telepoint_get')
    
    with(tp)
    {
        instance_destroy()
    }
}
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Movement Physics

// Variable Binding
k_left      =keyboard_check(global.k[? 'left'])
k_right     =keyboard_check(global.k[? 'right'])
k_up        =keyboard_check(global.k[? 'up'])
k_down      =keyboard_check(global.k[? 'down'])
k_jump      =keyboard_check_pressed(global.k[? 'jump'])
k_attack    =keyboard_check_pressed(global.k[? 'throw'])
k_dash      =keyboard_check_pressed(global.k[? 'dash'])

move_x      =k_right-k_left

// Direction
if move_x!=0
{
    image_xscale=move_x
}

if dash_count=dash_max and jump_count=jump_max
{
    if flash_lock=false and global.flash_enabled=true
    {
        flash=0.5
        flash_lock=true
    }
}
else
{
    flash_lock=false
}

// State Machine
switch(state)
{
    case (s.idle):
    {
        dash_count=dash_max
        jump_count=jump_max
        
        if move_x!=0
        {
            state=s.move
        }
                
        if k_dash and dash_count&gt;0
        {
            state=s.dash
            dash_timer=0
        }
        
        if k_jump and jump_count&gt;0
        {
            state=s.jump
        }
        
        if k_attack and can_throw
        {
            state=s.attack
        }
        
        if (k_up-k_down)&lt;0
        {
            sprite_index=spr_player_down
        }
        
        if (k_up-k_down)&gt;0
        {
            sprite_index=spr_player_up
        }
        
        if (k_up-k_down)=0
        {
            image_speed=0.5
            sprite_index=spr_player_idle
        }
        
        if !place_meeting(x,y+1,obj_collision)
        {
            state=s.fall
        }
           
    break}
    
    case(s.move):
    {
        if move_x=0
        {
            state=s.idle
        }
        
        if !place_meeting(x,y+1,obj_collision)
        {
            state=s.fall
        }
        
        dash_count=dash_max
        jump_count=jump_max
        
        sprite_index=spr_player_move
        
        if k_dash and dash_count&gt;0
        {
            state=s.dash
            dash_timer=0
        }
        
        if k_jump and jump_count&gt;0
        {
            state=s.jump
        }
        
        if k_attack and can_throw
        {
            state=s.attack
        }
        
        move_hsp=move_speed*move_x
        
        if image_index=2 or image_index=6
        {
            play_snd(snd_player_move)
            create_particles(x,y+10,'move')
            move_timer=0
        }
        else
        {
            move_timer+=1
        }
        
        vsp=0
           
    break}
    
    case(s.jump):
    {
        vsp=-jump_speed
        jump_count-=1
        
        state=s.fall
        global.jump_count+=1
        play_snd(snd_player_jump)
        
    break}
    
    case(s.attack):
    {        
        can_throw=false
        axe=instance_create(x,y,obj_axe)
        
        if (k_up-k_down)!=0
        {  
            if (k_up-k_down)&gt;0
            {
                axe.vsp=-12
                axe.hsp=0
            }
            
            if (k_up-k_down)&lt;0
            {
                axe.vsp=12
                axe.hsp=0
            }
        }
        else 
        {
            axe.vsp=0
            axe.hsp=12*image_xscale
        }
               
        state=s.fall
        
    break}
    
    case(s.dash):
    {
        if dash_timer=0
        {
            dash_count-=1
            dash_timer=5
            global.dash_count+=1
            play_snd(snd_player_dash)
        }
        
        if (place_meeting(x+1,y,obj_collision) and move_x=1) or (place_meeting(x-1,y,obj_collision) and move_x=-1)
        {
            dash_count=dash_max
            jump_count=jump_max
            
            state=s.wall
        }

        vsp=0
        
        sprite_index=spr_player_dash
        
        dash_hsp=image_xscale*19
        
        dash_timer-=1
        
        if dash_timer=0
        {
            state=s.fall
            dash_hsp=0
        }
        
        if k_jump and jump_count&gt;0
        {
            state=s.jump
        }
        
        if place_meeting(x,y+1,obj_collision)
        {
            create_particles(x,y+10,'move')
        }
        else
        {
            create_particles(x,y,'dash')
        }
          
    break}
    
    case(s.fall):
    {
        
        fall_hsp=move_speed*move_x
        vsp+=grav 
        
        if (place_meeting(x+1,y,obj_collision) and move_x=1) or (place_meeting(x-1,y,obj_collision) and move_x=-1)
        {
            dash_count=dash_max
            jump_count=jump_max
            
            state=s.wall
        }
        
        if place_meeting(x,y+vsp,obj_collision)
        {
            if sign(vsp)=-1
            {
                while !place_meeting(x,y+sign(vsp),obj_collision)
                {
                    y+=sign(vsp)
                }
                
                vsp=0
            }
            else
            {
                state=s.idle
            }
        }
        
        if k_dash and dash_count&gt;0
        {
            state=s.dash
            dash_timer=0
        }
        
        if k_jump and jump_count&gt;0
        {
            state=s.jump
        }
        
        if k_attack and can_throw
        {
            state=s.attack
        }
             
    break}
    
    case(s.wall):
    {           
        sprite_index=spr_player_wall
        
        wall_hsp=move_speed*move_x
        
        vsp+=1
        
        if vsp&gt;grav*3
        {
            vsp=grav*3
            if !audio_is_playing(snd_player_move_wall)
            {
                play_snd(snd_player_move_wall,'repeat')
            }

        }
       
        if !((place_meeting(x+1,y,obj_collision) and move_x=1) or (place_meeting(x-1,y,obj_collision) and move_x=-1))
        {
            state=s.fall
            stop_snd(snd_player_move_wall)
        }
        
        if place_meeting(x,y+vsp,obj_collision)
        {
            if sign(vsp)=-1
            {
                while !place_meeting(x,y+sign(vsp),obj_collision)
                {
                    y+=sign(vsp)
                }
                
                vsp=0
            }
            else
            {
                state=s.idle
                stop_snd(snd_player_move_wall)
            }
        }
        
        if k_jump and jump_count&gt;0
        {
            if place_meeting(x+1,y,obj_collision)
            {
                wall_hsp=-jump_speed
                create_particles(x+10,y,'wall_jump')
            }
            
            if place_meeting(x-1,y,obj_collision)
            {
                wall_hsp=jump_speed
                create_particles(x-10,y,'wall_jump')
            }

            state=s.jump
            stop_snd(snd_player_move_wall)
        }
        
        if k_dash and dash_count&gt;0
        {
            state=s.dash
            dash_timer=0
            stop_snd(snd_player_move_wall)
        }
                
        if k_attack and can_throw
        {
            state=s.attack
            stop_snd(snd_player_move_wall)
        }
        
        if wall_timer=5
        {
            if place_meeting(x+1,y,obj_collision)
            {
                create_particles(x+10,y,'wall')
            }
            
            if place_meeting(x-1,y,obj_collision)
            {
                create_particles(x-10,y,'wall')
            }
            
            wall_timer=0
        }
        else
        {
            wall_timer+=1
        }
             
    break}    
}

// Fall/Jump Sprites
if state=s.fall or state=s.jump
{
    if vsp&gt;0
    {
        sprite_index=spr_player_fall
    }
    if vsp&lt;0
    {
        sprite_index=spr_player_jump
    }
}

if sprite_index=spr_player_fall or sprite_index=spr_player_jump
{
    if image_index=7
    {
        image_speed=0
    }
    else
    {
        image_speed=0.5
    }
}

// Applying speeds to position
combine_hsp()

if place_meeting(x+hsp,y,obj_collision)
{
    while !place_meeting(x+sign(hsp),y,obj_collision)
    {
        x+=sign(hsp)
    }
}
else
{
    x+=hsp
}

if place_meeting(x,y+vsp,obj_collision)
{
    while !place_meeting(x,y+sign(vsp),obj_collision)
    {
        y+=sign(vsp)
    }
    
    create_particles(x,y,'land')
    vsp=0
}
else
{
    y+=vsp
}

move_snap(1,1)
 

</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Flash

if flash&gt;0
{
    shader_set(flash_white)  
    shader_set_uniform_f(shader_get_uniform(flash_white,'alpha'),flash)      
    draw_self()    
    shader_reset()
    
    flash-=0.125
}
else
{
    draw_self()
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
