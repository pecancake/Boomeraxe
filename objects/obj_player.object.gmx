<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>spr_player_fall</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>-10</depth>
  <persistent>0</persistent>
  <parentName>&lt;undefined&gt;</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Initialize
create_enum()

// Movement Variables
dash_max=1
jump_max=2
dash_count=dash_max
jump_count=jump_max

move_hsp=0
dash_hsp=0
fall_hsp=0
wall_hsp=0
jump_hsp=0
hsp=0
vsp=0
grav=0.6

// Other
can_throw=true
state=s.idle
move_speed=4
jump_speed=10
dash_timer=0
move_timer=0
wall_timer=0

</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Movement Physics

// Variable Binding
k_left      =keyboard_check(vk_left)
k_right     =keyboard_check(vk_right)
k_up        =keyboard_check(vk_up)
k_down      =keyboard_check(vk_down)
k_attack    =keyboard_check(ord('X'))
k_jump      =keyboard_check_pressed(ord('Z'))
k_dash      =keyboard_check_pressed(vk_shift)

move_x      =k_right-k_left

// State Machine
switch(state)
{
    case (s.idle):
    {
        dash_count=dash_max
        jump_count=jump_max
        
        if move_x!=0
        {
            state=s.move
        }
        
        if k_attack and can_throw
        {
            state=s.attack
        }
        
        if k_dash and dash_count&gt;0
        {
            state=s.dash
        }
        
        if k_jump and jump_count&gt;0
        {
            state=s.jump
        }
        
        if (k_up-k_down)&gt;0
        {
            sprite_index=spr_player_down
        }
        
        if (k_up-k_down)&lt;0
        {
            sprite_index=spr_player_up
        }
        
        if (k_up-k_down)=0
        {
            image_speed=0.5
            sprite_index=spr_player_idle
        }
        
        if !place_meeting(x,y+1,obj_collision)
        {
            state=s.fall
        }
           
    break}
    
    case(s.move):
    {
        if move_x=0
        {
            state=s.idle
            break
        }
        
        if !place_meeting(x,y+1,obj_collision)
        {
            state=s.fall
        }
        
        dash_count=dash_max
        jump_count=jump_max
        
        sprite_index=spr_player_move
        
        if k_jump and jump_count&gt;0
        {
            state=s.jump
        }
        
        if k_attack and can_throw
        {
            state=s.attack
        }
        
        if k_dash and dash_count&gt;0
        {
            state=s.dash
        }
        
        move_hsp=move_speed*move_x
        
        if move_timer=5
        {
            create_particles(x,y+10,'move')
            move_timer=0
        }
        else
        {
            move_timer+=1
        }
        
        vsp=0
           
    break}
    
    case(s.jump):
    {
        vsp=-jump_speed
        jump_count-=1
        
        //create_particles(x,y,'jump')
        state=s.fall
        
    break}
    
    case(s.attack):
    {
        sprite_index=spr_player_attack
        
        can_throw=false
        axe=instance_create(x,y,obj_axe)
        
        if (k_up-k_down)!=0
        {  
            if (k_up-k_down)&gt;0
            {
                axe.vsp=-12
                axe.hsp=0
            }
            
            if (k_up-k_down)&lt;0
            {
                axe.vsp=12
                axe.hsp=0
            }
        }
        else 
        {
            axe.vsp=0
            axe.hsp=12*image_xscale
        }
        
        //axe.hsp+=hsp//*sign(axe.hsp)
        //axe.vsp+=vsp//*sign(axe.vsp)
        
        state=s.fall
        
    break}
    
    case(s.dash):
    {
        if dash_timer=0
        {
            dash_count-=1
            dash_timer=6
            dash_dir=image_xscale
        }
        
        vsp=0
        
        sprite_index=spr_player_dash
        
        dash_hsp=dash_dir*16
        
        dash_timer-=1
        
        if dash_timer=0
        {
            state=s.fall
            dash_hsp=0
        }
        
        if k_jump and jump_count&gt;0
        {
            state=s.jump
        }
        
        create_particles(x,y,'dash')
        
        if place_meeting(x,y+1,obj_collision)
        {
            create_particles(x,y+10,'move')
        }
          
    break}
    
    case(s.fall):
    {
        
        fall_hsp=move_speed*move_x
        vsp+=grav 
        
        if (place_meeting(x+1,y,obj_collision) and move_x=1) or (place_meeting(x-1,y,obj_collision) and move_x=-1)
        {
            dash_count=dash_max
            jump_count=jump_max
            
            state=s.wall
        }
        
        if place_meeting(x,y+vsp,obj_collision)
        {
            if sign(vsp)=-1
            {
                while !place_meeting(x,y+sign(vsp),obj_collision)
                {
                    y+=sign(vsp)
                }
                
                vsp=0
            }
            else
            {
                state=s.idle
            }
        }
        
        if k_jump and jump_count&gt;0
        {
            state=s.jump
        }
        
        if k_dash and dash_count&gt;0
        {
            state=s.dash
        }
        
        if k_attack and can_throw
        {
            state=s.attack
        }  
             
    break}
    
    case(s.wall):
    {
        sprite_index=spr_player_wall
        
        wall_hsp=move_speed*move_x
        
        vsp+=1
        
        if vsp&gt;grav*3
        {
            vsp=grav*3
        }
       
        if !((place_meeting(x+1,y,obj_collision) and move_x=1) or (place_meeting(x-1,y,obj_collision) and move_x=-1))
        {
            state=s.fall
        }
        
        if place_meeting(x,y+vsp,obj_collision)
        {
            if sign(vsp)=-1
            {
                while !place_meeting(x,y+sign(vsp),obj_collision)
                {
                    y+=sign(vsp)
                }
                
                vsp=0
            }
            else
            {
                state=s.idle
            }
        }
        
        if k_jump and jump_count&gt;0
        {
            if place_meeting(x+1,y,obj_collision)
            {
                wall_hsp=-jump_speed
                create_particles(x+10,y,'wall_jump')
            }
            
            if place_meeting(x-1,y,obj_collision)
            {
                wall_hsp=jump_speed
                create_particles(x-10,y,'wall_jump')
            }

            state=s.jump
        }
        
        if k_dash and dash_count&gt;0
        {
            state=s.dash
        }
        
        if k_attack and can_throw
        {
            state=s.attack
        }
        
        if wall_timer=5
        {
            if place_meeting(x+1,y,obj_collision)
            {
                create_particles(x+10,y,'wall')
            }
            
            if place_meeting(x-1,y,obj_collision)
            {
                create_particles(x-10,y,'wall')
            }
            
            wall_timer=0
        }
        else
        {
            wall_timer+=1
        }
             
    break}    
}

// Fall/Jump Sprites
if state=s.fall or state=s.jump
{
    if vsp&gt;0
    {
        sprite_index=spr_player_fall
    }
    if vsp&lt;0
    {
        sprite_index=spr_player_jump
    }
}

if sprite_index=spr_player_fall or sprite_index=spr_player_jump
{
    if image_index=7
    {
        image_speed=0
    }
    else
    {
        image_speed=0.5
    }
}
// Direction
if move_x!=0
{
    image_xscale=move_x
}

// Applying speeds to position
combine_hsp()

if place_meeting(x+hsp,y,obj_collision)
{
    while !place_meeting(x+sign(hsp),y,obj_collision)
    {
        x+=sign(hsp)
    }
}
else
{
    x+=hsp
}

if place_meeting(x,y+vsp,obj_collision)
{
    while !place_meeting(x,y+sign(vsp),obj_collision)
    {
        y+=sign(vsp)
    }
    
    create_particles(x,y,'land')
    vsp=0
}
else
{
    y+=vsp
}

move_snap(1,1)


</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Non-Wall Collisions

sp=instance_place(x,y,obj_savepoint)
if sp!=noone and sp.state=s.close
{
    obj_savepoint.state=s.close
    sp.state=s.open
    sp.peek=120
    create_particles(sp.x+10,sp.y+10,'savepoint_get')
}

if place_meeting(x,y,obj_spike)
{
    instance_destroy()
    instance_create(x,y,obj_player_death)
}

</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
